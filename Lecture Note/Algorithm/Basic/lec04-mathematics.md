# [알고리즘 기초] 4강 강의 노트 - 수학

> ### Contents
>
> - [나머지 연산](#나머지-연산-)
> - [최대공약수](#최대공약수-)
> - [최소공배수](#최소공배수-)
> - [진법 변환](#진법-변환-)
> - [소수](#소수-)
>   - [에라토스테네스의 체](#에라토스테네스의-체-)
>   - [골드바흐의 추측](#골드바흐의-추측-)
> - [소인수분해](#소인수분해-)

<br/>

### 나머지 연산 [↑](#contents)

- 컴퓨터의 정수는 저장할 수 있는 범위가 지정되어 있기 때문에, 답을 M으로 나눈 나머지를 출력하라는 문제가 종종 나온다.
- `(A + B) mod M = ((A mod M) + (B mod M)) mod M` (모듈러 연산의 덧셈)
- `(A × B) mod M = ((A mod M) × (B mod M)) mod M` (모듈러 연산의 곱셈)
- 모듈러 연산에는 나눗셈이 없다. (모듈러 역수를 구해야 함)
- 뺄셈의 경우에는 먼저 `mod` 연산을 한 결과가 음수가 나올 수 있기 때문에 다음과 같이 해야 한다.
- `(A - B) mod M = ((A mod M) - (B mod M) + M) mod M`

<br />

### 최대공약수 [↑](#contents)

- 최대공약수는 줄여서 GCD(Greatest Common Division)라고 쓴다.

- 두 수 A와 B의 최대공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수이다.

- 최대공약수가 1인 두 수를 서로소(Coprime)라고 한다.

- 최대공약수를 구하는 가장 쉬운 방법은 2부터 `min(A, B)` 까지 모든 정수로 나누어 보는 방법이다. (시간복잡도 **O(N)**)

  ```c++
  int g = 1;
  for (int i = 2; i <= min(a, b); i++) {
    if (a % 1 == 0 && b % i == 0) {
      g = i;
    }
  }
  ```

- **유클리드 호제법**(Euclidean algorithm)을 이용하여 최대공약수를 더 빨리 구할 수 있다.

  - `a % b = r` 일 때, `GCD(a, b) = GCD(b, r)` 이다.
  - r이 0이 될 때의 b가 최대 공약수가 된다.
  - 즉, `GCD(24, 16) = GCD(16, 8) = GCD(8, 0) = 8`

  ```c++
  // 재귀함수를 사용해서 구현한 유클리드 호제법
  int gcd(int a, int b) {
    if (b == 0) return a;
    else return gcd(b, a % b);
  }
  ```

  ```c++
  // 재귀함수를 사용하지 않고 구현한 유클리드 호제법
  int gcd(int a, int b) {
    while (b != 0) {
      int r = a % b;
      a = b;
      b = r;
    }
    return a;
  }
  ```

<br />

### 최소공배수 [↑](#contents)

- 최소공배수는 줄여서 LCM(Least Common Multiple)이라고 한다.
- 두 수의 최소공배수는 두 수의 공통된 배수 중에서 가장 작은 정수이다.
- 최소공배수는 GCD를 응용해수 구할 수 있다.
  - `GCD(a, b) = g` 일 때, 최소공배수 l에 대해 `l = g × (a / g) × (b / g)` 이다.

<br />

### 진법 변환 [↑](#contents)

- 10진법 수 N을 B진법으로 바꾸려면 N이 0이 될 때 까지 나머지를 계속 구하면 된다.

> ex) 11을 3진법으로 바꾸는 방법
>
> - 11 / 3 = 3 ⋯ **2**
> - 3 / 3 = 1 ⋯ **0**
> - 1 / 3 = 0 ⋯ **1**
>
> 11은 3진법으로 **102** 이다. (뒤에서 부터 읽어야 함.)

- B진법 수 N을 10진수로 바꾸려면 B^k을 곱해가면서 더하면 된다.
  - 3진법 수 102 = 1 × 3^2 + 0 × 3^1 + 2 × 3^0 = 11
- A진법을 B진법으로 바꾸려면 **A진법 → 10진법 → B진법** 의 과정을 거치면 된다.

<br />

### 소수 [↑](#contents)

- 약수가 1과 자기 자신 밖에 없는 수를 의미한다.

- N이 소수가 되려면 2보다 크거나 같고, **N-1** 보다 작거나 같은 자연수로 나누어 떨어지면 안된다.

- 1 부터 100까지 소수

  - 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97

  ```c++
  bool prime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= n - 1; i++) {
      if (n % i == 0) return false;
    }
    return true;
  }
  ```

- N의 약수 중에서 가장 큰 것은 N/2보다 작거나 같기 때문에, **N/2**보다 작거나 같은 수로 나누어 떨어지면 안된다. (효율적인 소수 계산)

  ```c++
  bool prime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= n /21; i++) {
      if (n % i == 0) return false;
    }
    return true;
  }
  ```

- N이 소수가 아니라면, N = a × b 로 나타낼 수 있고(a ≤ b), a와 b의 차이가 가장 작은 경우는 루트 N이기 때문에, **루트 N** 모다 작거나 같은 자연수로 나누어 떨어지면 안된다. (더 효율적인 소수 계산)

  ```c++
  bool prime(int n) {
    if (n < 2) return false;
    for (int i = 2; i*i <= n; i++) {
      if (n % i == 0) return false;
    }
    return true;
  }
  ```

#### 에라토스테네스의 체 [↑](#contents)

- 1부터 N까지 범위 안에 들어가는 모든 소수를 구하려면 에라토스테네스의 체를 사용한다.

1. 2부터 N까지의 모든 수를 써놓는다.

2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.

3. 그 수는 소수이다.

4. 이제 그 수의 배수를 모두 지운다.

   ```c++
   int p[100];  // 소수 저장
   int pn = 0;  // 소수의 갯수
   bool c[101]; // 지워졌으면 true
   int n = 100; // 100까지의 소수
   for (int i = 2; i <= n; i++) {
     if (c[i] == false) {
       p[pn++] = i;
       for (int j = i*i; j <= n; j += i) { // 보다 더 효율적인 계산 가능
         c[j] = true;
       }
     }
   }
   ```

#### 골드바흐의 추측 [↑](#contents)

- **2**보다 큰 모든 **짝수**는 두 소수의 합으로 표현 가능하다.
- (위 문장에 3을 더하면) **5**보다 큰 모든 **홀수**는 세 소수의 합으로 표현 가능하다.
- 10^18 이하에서는 참인 것이 증명되어 있지만, 그 이상은 아직 증명되지 않은 문제이다.

<br / >

### 소인수분해 [↑](#contents)

- 정수 N을 소수의 곱으로 분해

- 소수를 구하지 않고도 해결할 수 있다.

- N을 소인수분해 했을 때, 나타날 수 있는 인수 중에서 가장 큰 값은 **루트 N**이다.

- 따라서, 2부터 루트 N까지 for문을 돌면서 N을 나눌 수 없을 때 까지 계속해서 나누면 된다.

  ```c++
  for (int i = 2; i * i <= n; i++) {
    while (n % i == 0) {
      printf("%d\n", i);
      n /= i;
    }
  }
  if (n > 1) printf("%d\n", n);
  ```

  